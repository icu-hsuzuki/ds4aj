# 変形（Transform） {#transform}

> ここでは、`tidyverse` パッケージを構成する `dplyr` パッケージを用いて、データを変形することを学びます。変形とは、例えば、データのなかのある条件を満たす行や列を抽出（取り出）したり、特定の列を修正したり、データの中のいくつかの列に含まれる情報をもとに計算して、新たな列を作ったり、グループに分けたり、順番を入れ替えたりといったことです。データを集約し（まとめ）たり、グラフを作成するときにも、必要不可欠な作業です。
>
> `dplyr` パッケージを用いて、二つのデータを結合することなども可能ですが、それは、あとから扱います。これも、`tidyverse` パッケージを構成する `tidyr` パッケージ による変形も、後ほど扱います。

`dplyr` パッケージは、`tidyverse` パッケージをインストールしたり、使えるように `library(tidyverse)` で読み込んだりするときに、一緒に読み込まれますから、あらためて、`dplyr` を指定する必要はありません。

```{r}
library(tidyverse)
```

## `dplyr` [概要](https://dplyr.tidyverse.org)

`dplyr` はデータ操作の文法のようなもので、最も一般的なデータ操作に役立つ一貫したいくつかの「動詞」の役割を果たすものを提供しています。

-   `select()` 変数をその名前によって選択 - 列の選択に対応します。
-   `filter()` ケースをその値によって選択 - 行の選択に対応します。
-   `mutate()` 新しい変数を既存の値を使って定義します - 新しい列を作成することに対応しています。
-   `summarise()`[^25-transform-1] たくさんの値を一つの値に集約します - 代表値（平均、メディアンなど）を求めることに対応します。
-   `arrange()` 行の順序を変更します。
-   `group_by()` グループを指定した表に変換します。

[^25-transform-1]: `summarize()` とつづりをアメリカ式にしても問題ありません。他にも、さまざまな用語は、アメリカ式の綴りでも、イギリス式でも、問題ないようになっています。

さらに詳しく知りたい場合は Console（コンソールに）vignette("dplyr") と入れるか、[こちら](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html) を参照してください。上では、一つの表について述べていますが、二つの表の扱い方は、Console（コンソール）に vignette("two-table") と入れるか、[こちら](https://cran.r-project.org/web/packages/dplyr/vignettes/two-table.html) を参照してください。二つの表の扱いについては、後から説明します。

`dplyr` を初めて使われる場合には、まず [R for data science (2e) Transform](https://r4ds.hadley.nz/transform) を学ばれることをお勧めします。以下も、このサイトに沿った説明をします。

### [`select`](https://dplyr.tidyverse.org/reference/select.html): 名前とタイプによって、列（変数）を選択

| 補助関数      | 条件                   | 例                                                    |
|---------------|------------------------|-------------------------------------------------------|
| \-            | 列の除去               | select(iris, -Species)                                |
| :             | 列の範囲               | select(iris, 1:4)                                     |
| contains()    | 指定文字列を含         | select(iris, contains("Width"))                       |
| ends_with()   | 指定文字列で終わる     | select(iris, ends_with("th"))                         |
| matches()     | 正規表現に適合         | select(iris, matches("S"))                            |
| num_range()   | 末尾の指定数値範囲     | Not applicable with iris                              |
| one_of()      | 指定した名前に含まれる | select(iris, one_of(c("Sepal.Width", "Petal.Width"))) |
| starts_with() | 指定文字列で始まる     | select(iris, starts_with("Petal"))                    |

「正規表現」という言葉が登場します。検索などでは基本的なものですので、ネット上で調べてください。適切に動作するかを、チェックする、正規表現チェッカーもあります。参照：[Wikipedia](https://ja.wikipedia.org/wiki/正規表現)

### [`filter`](https://dplyr.tidyverse.org/reference/filter.html): 列の値の条件に適合した行の選択

| 論理作用素 | 条件             | 例        |
|------------|------------------|-----------|
| \>         | y より大きい x   | x \> y    |
| \>=        | y 以上の x       | x \>= y   |
| \<         | y より小さい x   | x \< y    |
| \<=        | y 以下の x       | x \<= y   |
| ==         | y と等しい x     | x == y    |
| !=         | y と等しくない x | x != y    |
| is.na()    | 値が NA である x | is.na(x)  |
| !is.na()   | 値が NA でない x | !is.na(x) |

NA は、not available 値が存在しないという意味です。欠損値のことで、`df_wdi` などには、たくさん、NA が出てきます。欠損値の扱いも、データサイエンスにおいてはとても大切です。

### [`arrange`](https://dplyr.tidyverse.org/reference/arrange.html)

`arrange()` では、選択した列の値によって、行を並び替えます。

注意点すべきは、他の、`dplyr` の動詞とは異なり、基本的に、グループ化は、無視し、その表全体に適用します。グループ内で並び替えをしたい場合には、グループ化した変数を指定するか、`.by_group = TRUE` とします。

### [`mutate`](https://dplyr.tidyverse.org/reference/mutate.html)

新しい列を作成または、既存の列を修正、削除します。

以下は便利な補助関数の例です。Help を参照してください。利用するときに、少しずつ説明していきます。ある程度慣れてきたら、どのようなことができるかを把握しておくことは、助けになります。

-   +, -, log(), など：通常の数学記号を表します。

-   `lead()`, `lag()`：`lead` は次の値、`lag` は一つ前の値です。

-   `dense_rank()`, `min_rank()`, `percent_rank()`, `row_number()`, `cume_dist()`, ntile(): `rank` は、階級、順序を決めます。`base::rank` もあります。基本的に、同じ値があったときに、どのように順序を決めるかがそれぞれによって異なります。

-   `cumsum()`, `cummean()`, `cummin()`, `cummax(),` `cumany()`, `cumall()`: cum は、cumulative（累計）ですから、`cumsum` は累計、`cummean()` は、その値までの平均（小計）、`cummin()` は、その値までの最小、`cummax()` その値までの最大、 `cumany()`, `cumall()` は、Help を参照してください。

-   `na_if()`, `coalesce()`: `na_if(x,y)` は、x の中で、y と等しいものは、NA に置き換え、`coalesce()` は、最初の欠損していない値を返します。

### [`group_by`](https://dplyr.tidyverse.org/reference/group_by.html)

指定した列の値によって表全体をグループ化した表を作成します。表自体が変形されるわけではありませんから、注意してください。次の、`summarize` と合わせて利用すると便利です。

### [`summarise` または `summarize`](https://dplyr.tidyverse.org/reference/summarise.html)

値の集約 (summarize) または、集計に利用します。グループ化された表の場合には、そのグループごとに、値を集約します。

#### 集約のための関数

`summarize` には、 `sum()`, `max()`, や `mean()` が使われますが、ベクトルに対して定義され、一つの値だけを出力する関数でであれば、なんでも使うことができます。以下は、その例です。それぞれの関数については、Help で調べてください。

1.  特定の値 - `mean(x)`, `median(x)`, `quantile(x, 0.25)`, `min(x)`, `max(x)`

2.  分布の値 - `sd(x)`, `var(x)`, `IQR(x)`, `mad(x)`

3.  値の位置 - `first(x)`, `nth(x, 2)`, `last(x)`

4.  個数 - `n_distinct(x),` `n()` （引数なし：表またはグループのサイズ）

5.  論理値の数または割合 - `sum(!is.na(x)), mean(y == 0)`

条件文で値を指定することも可能です。

-   `if_else()`, `recode()`, case_when()

注: *quantile（分位数） と quartile（四分位数）：分位数はデータセットを任意の個数の等しい部分に分割するための値を示し、四分位数はデータセットを4つの等しい部分に分割するための特定の値。*

### パイプ（Pipe）`%>%` `|>`

`pipe` in R は、すでに説明してましたが、ここにまとめておきます。

`%>%` は、`tidyverse` パッケージで、関数のチェーン化を行うために使用されるパイプ演算子ですが、R 4.1 以降は、`|>` が、R に組み込まれた、ネイティブなパイプライン演算子になっています。`tidyverse` を使っているときは、どちらを使うことも可能ですが、`|>` を使うことをお勧めします。R の versoin を確認するには、コンソール（Console）で、`R.Version()` または、`R.version$version.string` とします。

#### **備考**

1.  パイプを使うコードで、複数行にまたがるときは、`|>` の後で、改行してください。次の行に続くことがわかります。

2.  実際には、`tidyverse` の `%>%` と、R に組み込まれた `|>` とは多少異なるようです。こちらの[記事](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/)をご覧ください。本書では、`|>` を使いますが、注意が必要な場合は、コメントします。

## 例から学ぶ `dplyr,` I

### Data `iris`

R 起動時に読み込まれる、`datasets` の中の、`iris` （あやめのデータ）を使い、いくつかの例を示します。`iris` は、何もしなくてもそのまま使えますが、もし、下の結果と違う場合には、すでに、`iris` を使い、変形などをしている可能性がありますから、そのときは、下のコードを実行してください。

```{r}
df_iris <- datasets::iris
```

確認します。

```{r}
head(df_iris)
```

```{r}
str(df_iris)
```

`df_iris` データは、名前のついた5個の変数（列）Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species があり、それぞれ、150の値（observations (obs.) 観察値）からなっています。5番目の Species は、三つのレベルのファクター（factor）setosa, versicolor ともう一つ virginica からなっていることがわかります。`unique` は、ベクトル型の変数（今の場合は、`iris` の `Species` という列）の中の異なる値を抽出します。ファクター（factor）は、ある分け方がされているという意味です。いずれ説明します。

```{r}
unique(df_iris$Species)
```

### `select` 列の抽出

### `select` 1 - 第 1, 2, 5 列を抽出

```{r}
head(select(df_iris, c(1,2,5)))
```

第1列、第2列、第5列を、`c(1,2,5)` で表しています。列名で指定することもできます。

`head(select(df_iris, c(1,2,5)))` としてありますから、その最初の6行を表示していますが、新しい変数を割り当ててはいませんから、`df_iris` 自体は変更されていません。

```{r}
head(df_iris)
```

第1列、第2列、第5列を選んだものを、あとから使いたいときは、新しい名前をつける必要があります。以下同様ですが、この場合だけ、`df_iris125` という名前（object name）をつけておきましょう。

```{r}
df_iris125 <- select(df_iris, c(1,2,5))
head(df_iris125)
```

#### パイプ（Pipe） `|>` を使ったコード

最初の例では `head(select(df_iris, c(1,2,5)))` としました。`head` の引数として、 `select(df_iris, c(1,2,5))` を使ったからです。しかし、慣れてくると、順番に関数を適用することを表現するには、 パイプを使うのも便利です。パイプでは、直前の出力が次の関数の第一引数として引き継がれるというルールになっています。以下のようになります。

```{r}
df_iris |> select(1,2,5) |> head()
```

もちろん、`select(c(1,2,5)`) でも同じ結果が得られます。より、詳しく知りたい場合には、Help に `|>` と入れて説明を読んでください。

In the following, we use pipes.

### `select` 2 - Species 列以外

列名の前に、`-` ハイフン（半角）をつけると、その列以外を抽出します。

```{r}
select(df_iris, -Species) |> head()
```

### `select` 3 - 列を抽出するとともに列名も変更

新しい列名 = 現在の列名 という形式で、列名を変更することも可能です。

```{r}
select(df_iris, sl = Sepal.Length, sw = Sepal.Width, sp = Species) |> 
  head()
```

### `select` 4 - 列順の変更

```{r}
select(df_iris, c(5,3,4,1,2)) |> head()
```

#### 備考

1.  上の、`select` の 補助関数（helper functions）にも書きましたように、他にも様々な方法で、列を抽出することが可能です。たくさんの列がある表に出会ったら、ぜひ活用してください。
2.  最初は、それほど大きなデータ（表）を扱うことは少ないかもしれませんが、それでも、上で紹介した、列の名前を変更したり、列の順序を変更するなどは、有益です。使いやすく、見やすい形に変えてから、作業をすることはおすすめです。

### `filter` - 値による抽出

Species の列の値が、virginica であるものだけを抽出します。`==` とイコールが二つであることと、文字列の場合には、半角の引用符（double quote）でくくります。'verginica' でも同じです。（列名に空白や、特殊記号が含まれているときには、back tick と呼ばれる、反対向きの引用符で括ります。あとからその必要が生じたときに説明します。）

```{r}
filter(df_iris, Species == "virginica")
```

#### 備考　

-   `filter` は特に重要ですが、もう少し複雑なデータ（表）を例にとって、後ほど説明します。

-   上にも少し書いた、正規表現を使えるようになると、かなり複雑な条件での、抽出も可能になります。

### `arrange` - 昇順、降順

次の例では、Sepal.Length の値の、昇順（小さい順）にし、同じ値の中では、Spepal.Width の降順（大きい順 （desc は descending order からとったもの）にします。Sepal.Length の値が、4.4 の部分の、Sepal.Width の値をみてください。

```{r}
arrange(df_iris, Sepal.Length, desc(Sepal.Width)) 
```

### `mutate` - rank（階級）

小さい順に順序付けて新しい列を作成し、その順序で表示します。順序付も様々な種類があります。ここでは、同じ値のときには、同じ階級にしています。下の出力を右の方を見てください。1, 2, 2, 2, 5, ... となっています。

```{r}
df_iris |> mutate(sl_rank = min_rank(Sepal.Length)) |> 
  arrange(sl_rank) |> head()
```

#### 備考

1.  パイプを紹介したときにも書きましたが、改行は、`|>` のあとでしてください。
2.  `mutate` は、新しい列を加えるだけでなく、既存の列を修正するためにも使うことができます。修正した、データを使うときは、同じ名前のオブジェクトに `->` で、アサインすることも、可能ですが、新しい名前をつけて、新しいオブジェクトとして活用することをお勧めします。

### `group_by` and `summarize`

グループにわけて、グループごとに、平均を求めています。

```{r}
df_iris |> 
  group_by(Species) |>
  summarize(sl = mean(Sepal.Length), sw = mean(Sepal.Width), 
  pl = mean(Petal.Length), pw = mean(Petal.Width))
```

-   mean: `mean()` or `mean(x, na.rm = TRUE)` - 相加平均 (average)
-   median: `median()` , `median(x, na.rm = TRUE)` - 中央値（mid value）

以下のリンクには、もう少し例が書かれています。

[dplr_iris](https://icu-hsuzuki.github.io/da4r2022_note/dplyr-iris.nb.html)

## `dplyr` の参考文献

より詳しい説明は、教科書の該当箇所を見てください。

-   [R for Data Science, Part II Explore](https://r4ds.had.co.nz/wrangle-intro.html#wrangle-intro)
-   [R for Data Science (2e), Transform](https://r4ds.hadley.nz/transform)

### RStudio Primers: 対話型の演習問題

2.  Work with Data -- [r4ds: Wrangle, I](https://r4ds.had.co.nz/wrangle-intro.html#wrangle-intro)

-   [Working with Tibbles](https://rstudio.cloud/learn/primers/2.1)
-   [Isolating Data with dplyr](https://rstudio.cloud/learn/primers/2.2)
-   [Deriving Information with dplyr](https://rstudio.cloud/learn/primers/2.3)

## 例から学ぶ `dplyr,` II

### df_wdi, df_wdi_extra

前の章の `Tidyverse` で読み込み、概観した、世界開発指標（World Development Indicators）のデータを使います。[参照：WDI のデータ](https://icu-hsuzuki.github.io/ds4aj/tidyverse.html#wdi-のデータ)

```{r}
library(tidyverse)
library(WDI)
```

WDI の使い方は、世界銀行の部分で紹介しますが、はじめてのデータサイエンスの例でも紹介したように、データコードを利用して、データを読み込みます。ここでは、出生時の平均寿命と、一人当たりの　GDP と、総人口のデータを使います。

-   SP.DYN.LE00.IN: Life expectancy at birth, total (years) 出生時の平均寿命
-   SP.POP.TOTL: Population, total 総人口
-   NY.GDP.PCAP.KD: GDP per capita (constant 2015 US\$) 一人当たりの　GDP

次のコードで読み込みます。

```{r eval=FALSE}
df_wdi <- WDI(
  country = "all", 
  indicator = c(lifeExp = "SP.DYN.LE00.IN", pop = "SP.POP.TOTL", gdpPercap = "NY.GDP.PCAP.KD")
)
```

```{r echo=FALSE, eval=FALSE}
df_wdi <- WDI(
  country = "all", 
  indicator = c(lifeExp = "SP.DYN.LE00.IN", pop = "SP.POP.TOTL", gdpPercap = "NY.GDP.PCAP.KD")
)
write_csv(df_wdi, "./data/wdi.csv")
```

```{r echo=FALSE, eval=TRUE}
df_wdi <- read_csv("./data/wdi.csv")
```

```{r eval=FALSE}
df_wdi_extra <- WDI(
  country = "all", 
  indicator = c(lifeExp = "SP.DYN.LE00.IN", pop = "SP.POP.TOTL", gdpPercap = "NY.GDP.PCAP.KD"), 
  extra = TRUE
)
```

すこし、追加情報を付加したものも取得しておきます。

```{r eval=FALSE, echo=FALSE}
df_wdi_extra <- WDI(
  country = "all", 
  indicator = c(lifeExp = "SP.DYN.LE00.IN", pop = "SP.POP.TOTL", gdpPercap = "NY.GDP.PCAP.KD"), 
  extra = TRUE
)
write_csv(df_wdi_extra, "./data/wdi_extra.csv")
```

```{r eval=TRUE, echo=FALSE}
df_wdi_extra <- read_csv("./data/wdi_extra.csv")
```

```{r}
df_wdi_extra
```

### `ggplot2`

また、前の章の `Tidyverse` の説明で、あやめ（iris）のデータを使って、視覚化の説明を、散布図を使って、少ししました。参照：[ggplot2 グラフの描画](https://icu-hsuzuki.github.io/ds4aj/tidyverse.html#ggplot2-グラフの描画)

詳細は、次の、視覚化のところで説明しますが、視覚化のためには、データの変形、整理が必要であることを、理解していただくために、散布図と、箱ひげ図の基本的な場合のみ、以下のような形式で利用します。

**例1 散布図（scatter plot）**

```{r}
df_iris |> ggplot(aes(Sepal.Width, Sepal.Length)) + geom_point()
```

```{r}
df_iris |> ggplot(aes(Sepal.Width, Sepal.Length, color = Species)) +
  geom_point()
```

### `dplyr` の応用

すべて、`dplyr` というわけではありませんが、データを理解していきたいと思います。

二つのデータ `df_wdi` と `df_wdi_extra` がありました。この違いをまずは見ていきましょう。`colnames` は、列名が並んだもの（ベクトル）を出力します。

```{r}
df_wdi |> colnames()
```

```{r}
df_wdi_extra |> colnames()
```

`df_wdi_extra` の一部が、`df_wdi` のようです。

ここからは、しばらく、`df_wdi_extra` をみていきます。`range` は、最小、最大を見るのに使います。`df_wdi_extra$year` は、`df_wdi_extra` の `year` の列を取り出したもの（ベクトルといいます）です。

```{r}
range(df_wdi_extra$year)
```

`unique` を使って、その列で相異なるものをすべてリストすることもできます。

```{r}
unique(df_wdi_extra$income)
```

Aggregates とか、Not classified とか、NA は何を表しているのでしょうか。あとで見てみましょう。Google Public Data Explorer を使ったときに、Income Level というものがありました。覚えていますか。

**参考：[The World by Income and Region](https://datatopics.worldbank.org/world-development-indicators/the-world-by-income-and-region.html)**

```{r}
unique(df_wdi_extra$region)
```

これらは、あとで使いますから、残しておきましょう。そこで、country, iso2c, year, liefExp, pop, gdpPercap, income, region だけを取り出します。列を選択するので、`select` を使います。

```{r}
df_wdi3 <- df_wdi_extra |> select(country, iso2c, year, lifeExp, pop, gdpPercap, income, region)
df_wdi3
```

何列目かを指定することもできます。今回は少し多いので大変ですが。

```{r}
df_wdi_extra |> select(1,2,4,7,8,9,10,14)
```

Aggregates は何を意味しているのかみてみましょう。filter で、その行だけを取り出します。

```{r}
df_wdi3 |> filter(income == "Aggregates")
```

どうも、国ではなく、地域のようです。確認しておきましょう。unique を使って、

```{r}
unique(filter(df_wdi3, income == "Aggregates")$country)
```

とする手もありますが、パイプを使うときは、そのまま、country で異なるものを取り出した表にした方が簡単なので、`distinct` を使って、次のようにすることもできます。

```{r}
df_wdi3 |> filter(income == "Aggregates") |> distinct(country)
```

unique を使った場合と同じ表示にしたければ、最後に　`pull()` を付け加えて、その列だけを、並べて（ベクトル）表示することも可能です。

```{r}
df_wdi3 |> filter(income == "Aggregates") |> distinct(country) |> pull()
```

unclassified と、NA もみておきましょう。まず、Aggregates 以外を見たいので、等しくないは、`!=` を使います。

```{r}
df_wdi3 |> filter(income != "Aggregates") |> distinct(income) 
```

NA もなくなりましたから、あとは、Not classified ですね。

```{r}
df_wdi3 |> filter(income != "Aggregates") |> 
  filter(income == "Not classified") |> distinct(country) 
```

ベネズエラ（Venezuela, RB）は、経済が安定していないので、このようになるようです。これは、残しておいて、Aggregates でないものだけ選択しましょう。通常の、country のみですから、`df_wdi3c` としておきます。

```{r}
df_wdi3c <- df_wdi3 |> filter(income != "Aggregates") 
df_wdi3c
```

散布図を書いてみましょう。

```{r}
df_wdi3c |> ggplot(aes(gdpPercap, lifeExp)) + geom_point()
```

一応、なにか描けましたが、どうも、すごく点の数が多いですね。それと、欠損値もたくさんあるようです。また、gdpPercap でみると、値が小さいところに固まってあるようです。

まずは、すべての年について、値を使っていますから、2022 年に限ってみましょう。

```{r}
df_wdi3c |> filter(year == "2022") |>
  ggplot(aes(gdpPercap, lifeExp)) + geom_point()
```

どうも、何も現れません。2021 年ならどうでしょうか。

```{r}
df_wdi3c |> filter(year == 2021) |>
  ggplot(aes(gdpPercap, lifeExp)) + geom_point()
```

データがない国もあるようですが、どうやら表示されました。データがない国は、削除しておいたり region を 色で表したり、人口を、点の大きさで表したり、gdpPercap を log10 をとって、値を修正して表すなども可能ですが、それは、可視化の項目で学びます。

```{r}
df_wdi3c |> filter(year == 2021) |> drop_na(lifeExp, gdpPercap) |>
  ggplot(aes(gdpPercap, lifeExp, color = region, size = pop)) + 
  geom_point() + scale_x_log10()
```

こうしてみると、gdpPercap が大きい国ほど、lifeExp も大きい傾向があることも見えますね。

ここまでは、`select` と、`filter` を使ってきましたが、`arrange`、`mutate`、`group_by` や、`summarize` も使ってみましょう。

まず、gdpPercap は一人当たりの GDP でしたから、この値に、pop 人口をかければ、原理的には、GDP が得られることになります。（さまざまな基準がありますから、詳細は、調べてください。）順番を、入れ替えて、year の次に、gdp がくるようにしておきます。他にも、year の後に置くようにとの指示もできます。Help で確認してください。例も載っています。また、掛け算は、\* を使います。これを、df_wdi4c としておきましょう。また、year が順番になっていないのが気になりますから、大きい順に並べ替えておきましょう。

```{r}
df_wdi4c <- df_wdi3c |> mutate(gdp = pop*gdpPercap) |> 
  select(1,2,3,9,4,5,6,7,8) |> arrange(country, desc(year))
df_wdi4c
```

```{r}
df_wdi3c |> mutate(gdp = pop*gdpPercap, .after = year) |> 
  arrange(country, desc(year))
```

2022 年のデータはあまりないようですから、2021 年の GDP の大きい順に並べてみましょう。gdp が　2.052946e+13 などと書かれているのは、指数表示（Scientific Notation）で、e+3 は、1000 千、e+6 は、1,000,000 百万、e+9 は、1,000,000,000 千億、e+12 は、1,000,000,000,000 超です。つまり、アメリカの GDP は、だいたい、20兆ドル、日本は、4.5兆ドルと言ったところです。

```{r}
df_wdi4c |> filter(year == 2021) |> arrange(desc(gdp))
```

地域ごとの平均寿命を求めてみましょう。

```{r}
df_wdi4c |> drop_na(lifeExp) |> 
  group_by(region) |> summarize(lifeexpregion = mean(lifeExp)) |>
  arrange(desc(lifeexpregion))
```

income でも計算してみましょう。

```{r}
df_wdi4c |> drop_na(lifeExp) |> 
  group_by(income) |> summarize(lifeexpincome = mean(lifeExp)) |>
  arrange(desc(lifeexpincome))
```

ある年の値がないためにグラフがかけない場合もあります。各指標の年毎のデータがどれぐらいあるかみてみましょう。`is.na(x)` は、x が NA なら TRUE （値は 1）、x が NA でなければ、FALSE（値は 0）を返します。`!is.na(x)` はその否定ですから、逆になります。そこで、たとえば、`sum(!is.na(gdp))` は、gdp という列（年毎にグループ分けした）の中の、NA ではないものがいくつあるか数えることになります。sum は summation で、合計です。

```{r}
df_wdi4c |> group_by(year) |> 
  summarize(gdp_n = sum(!is.na(gdp)), lifeExp_n = sum(!is.na(lifeExp)), pop_n = sum(!is.na(pop)), gdpPercap_n = sum(!is.na(gdpPercap))) |> arrange(desc(year))
```

### `filter`

一番上に、国名（country）に、アフガニスタン（Afghanistan） がありましたから、aアフガニスタンのデータを選び、平均寿命（lifeExp: Life Expectancy）の折線グラフ（line graph）を描いてみましょう。まずは、filter で、アフガニスタンのデータを抽出します。スペルに注意してください。コピーをするのが安全かもしれません。折れ線グラフ（line graph）を描いてみましょう。まずは、filter で、アフガニスタンのデータを抽出します。スペルに注意してください。コピーをするのが安全かもしれません。

`filter(country == "Afghanistan")`

特定の値のデータを抽出するには、`==` を使うのでした。二つの `=` ですから、間違わないでください。

```{r}
df_wdi |> filter(country == "Afghanistan")
```

確認できましたか。

折線グラフを書きます。この場合は、GEOM は、`geom_line` です。

```{r}
df_wdi |> filter(country == "Afghanistan") |>
  ggplot(aes(x = year, y = lifeExp)) + geom_line()
```

アフガニスタンでは 1952年 の誕生時の平均寿命（life expectancy at birth）は　30歳以下 （28.8歳）でした。2007年でも50歳以下（48.8 歳）のようですね。改善されていることも確かです。

アフガニスタンと日本両方を抽出してみましょう。そのときは、 `country %in% c("Afghanistan", "Japan")`　とします。

```{r}
df_wdi |> filter(country %in% c("Afghanistan", "Japan"))
```

グラフにしてみましょう。今度は、区別のため、`color = country` を追加します。すると、線が違う色で表示されます。詳しくは、視覚化を参照してください。

```{r}
df_wdi |> filter(country %in% c("Afghanistan", "Japan")) |>
  ggplot(aes(x = year, y = lifeExp, color = country)) + geom_line()
```

どのような発見がありますか。かならず書き留めておいてください。

他の国についても調べるときは、国のリストがあるとよいので、 `unique(df_gm$country)` とすると、リストが得られます。`distinct(country)` で、異なる国を選択してから、その部分をベクトルとして出力することもできます。

```{r}
df_wdi |> distinct(country) |> pull()
```

このデータには 142 の国のデータがあることがわかりました。

BRICs を選んでみるとどうなるでしょうか。最近は、BRICS として、South Africa を加えることが増えてきているようです。

```{r}
df_wdi |> filter(country %in% c("Brazil", "Russia", "India", "China")) |>
  ggplot(aes(x = year, y = lifeExp, color = country)) + geom_line()
```

ロシアが含まれていないことがわかります。ロシアは、以前は、ソビエト社会主義連邦でしたから、国が変化したものは含まれていないのかもしれません。上の国のリストで見てもありませんね。2007年より新しいデータ、ロシアなども含むデータなど、実際のデータでも見てみたいですね。それは、また後ほど。

### 練習

1.  平均寿命 `lifeExp` を人口 `pop` や、一人当たりの GDP `gdpPercap` に変えて、試してみてください。
2.  ASEAN （東南アジア諸国連合）ではどうでしょうか。

-   Brunei, Cambodia, Indonesia, Laos, Malaysia, Myanmar, Philippines, Singapore.

-   このうち幾つの国がこのデータに含まれていますか。

3.  興味のある国をいくつか選んで、三つの指標について調べてみてください。

### `group_by` と `summarize`

データには大陸（`continent` ）という変数があります。幾つの大陸があり、それぞれの大陸のいくつ国のデータがこのデータには入っているでしょうか。

それぞれの大陸ごとの2007年の平均寿命の平均と中央値と最大、最小を求めてみましょう。

```{r}
df_wdi_extra |> filter(year == 2007) |> 
  group_by(income) |> 
  summarize(mean_lifeExp = mean(lifeExp), median_lifeExp = median(lifeExp), max_lifeExp = max(lifeExp), min_lifeExp = min(lifeExp), .groups = "keep")
```

## 練習問題

#### Gapminder と R Package `gapminder`

> Gapminder は オラ ロスリング（Ola Rosling） と アンナ ロスリング（Anna Rosling Rönnlund）と ハンス ロスリング（Hans Rosling）が設立した組織です。
>
> ハンス・ロスリング は、**FACTFULNESS（ファクトフルネス）10の思い込みを乗り越え、データを基に世界を正しく見る習慣** の著者です。
>
> また、R の gapminder パッケージには、ファクトフルネス にも登場するデータで、Gapminder サイトでも使っているデータの一部を、使いやすい、練習用のデータとして提供しているものです。

-   Gapminder: <https://www.gapminder.org>

    -   Test on Top: You are probably wrong about - upgrade your worldview
    -   Bubble Chart: <https://www.gapminder.org/tools/#$chart-type=bubbles&url=v1>
    -   Dallar Street: <https://www.gapminder.org/tools/#$chart-type=bubbles&url=v1>
    -   Data: <https://www.gapminder.org/data/>

-   R Package gapminder by Jennifer Bryan

    -   Package site: <https://CRAN.R-project.org/package=gapminder>
    -   Site: <https://github.com/jennybc/gapminder>
    -   Documents: <https://www.rdocumentation.org/packages/gapminder/versions/0.3.0>

-   Package Help `?gapminder` or `gapminder` in the search window of Help

    -   The main data frame gapminder has 1704 rows and 6 variables:
        -   country: factor with 142 levels
        -   continent: factor with 5 levels
        -   year: ranges from 1952 to 2007 in increments of 5 years
        -   lifeExp: life expectancy at birth, in years
        -   pop: population
        -   gdpPercap: GDP per capita (US\$, inflation-adjusted)

```{r packages, message=FALSE}
library(tidyverse)
library(gapminder)
library(WDI)
```

lifeExp, pop, gdpPercap と三つの指標があります。df_wdi と似ていますね。

1.  なにが同じで、何が違いますか。

2.  練習用のデータですが、df_wdi や、df_wdi_extra でしたようなことを試してみてください。

3.  値は同じでしょうか。

## 練習

### Posit Primers <https://posit.cloud/learn/primers>

データの変形：Work with Data -- r4ds: Wrangle, I

-   表の形式 Tibble：[Working with Tibbles](https://rstudio.cloud/learn/primers/2.1)

-   dplyr によるデータの抽出：[Isolating Data with dplyr](https://rstudio.cloud/learn/primers/2.2)

-   dplyr によるデータの変形：[Deriving Information with dplyr](https://rstudio.cloud/learn/primers/2.3)

## まとめ

### 関数

#### base

-   `colnames()`

-   `range()`

#### tidyverse

-   `select()`

-   `filter()`

-   `mutate()`

-   `summarize()` (`summarise()`)

-   `arrange()`

-   `distinct()`

-   `pull()`

-   `scale_x_log10()`

-   group_by()
